#+TITLE: emacs config
#+AUTHOR: Paul Davis
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* Setup

  To get this configuration working, clone the repr to
  ~$HOME/.emacs.d~ and open emacs. It will be the default
  configuration. Open up the file at ~$HOME/.emacs.d/init.org~.

  You will be prompted to execute the lisp in the file. Select the ~Y~
  option to run it once. This will tangle all of the blocks into the
  ~init.el~ file. After this is completed, exit emacs and reopen it.

  Open the ~init.org~ file again, and this time choose the ~!~ option
  to save the preference to run the embedded elisp. From now on, when
  you save the ~init.org~ file, the ~init.el~ file will be tangled and
  compiled.


* Configuration

** Init

   First, make sure this file will compile itself into a ~.el~ file
   that emacs can load. The repo's existing ~init.el~ will bootstrap
   this and replace itself in the process

   #+BEGIN_SRC emacs-lisp
     (defun tangle-init ()
       "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
       (when (equal (buffer-file-name)
                    (expand-file-name (concat user-emacs-directory "init.org")))
         ;; Avoid running hooks when tangling.
         (let ((prog-mode-hook nil))
           (org-babel-tangle)
           (byte-compile-file (concat user-emacs-directory "init.el")))))

     (add-hook 'after-save-hook 'tangle-init)
   #+END_SRC

   Inhibit the startup message

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC

   Set up package repos and ~use-package~

   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup nil)
     (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
     (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
     (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/"))
     (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
     (package-initialize)

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))
     ;; use-package should have these loaded
     (require 'diminish)
     (require 'bind-key)
   #+END_SRC

   Disable lock files

   #+BEGIN_SRC emacs-lisp
     (setq-default create-lockfiles nil)
   #+END_SRC

   Adjust backup file settings to be in a separate directory

   #+BEGIN_SRC emacs-lisp
     (defvar ds/backup-directory
       (expand-file-name "tmp/backups" user-emacs-directory)
       "Where backups go.")
     (defvar ds/autosave-directory
       (expand-file-name "tmp/autosave" user-emacs-directory)
       "Where autosaves go.")
     (make-directory ds/backup-directory t)
     (make-directory ds/autosave-directory  t)
     (setq backup-by-copying t
           backup-directory-alist `((".*" .  ,ds/backup-directory))
           auto-save-file-name-transforms `((".*"  ,ds/autosave-directory t))
           auto-save-list-file-prefix  ds/autosave-directory
           delete-old-versions t
           kept-new-versions 6
           kept-old-versions 2
           version-control t)
   #+END_SRC

   Remove menu bars and scroll bars

   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC

   Set the font

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'default-frame-alist '(font . "Ubuntu Mono-10"))
   #+END_SRC

   Setup custom file

   #+BEGIN_SRC emacs-lisp
     (defvar custom-file-location
       (expand-file-name "custom.el" user-emacs-directory)
       "File for customizations via \\[customize].")

     (setq custom-file custom-file-location)
     (if (file-readable-p custom-file-location)
         (progn
           (load custom-file)))
   #+END_SRC

** Basic Customizations

*** Indentation

    Fuck tabs

    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
      (setq-default tab-width 4)
      (setq-default tab-stop-list (number-sequence 4 120 4))
    #+END_SRC

    Setup electric indent

    #+BEGIN_SRC emacs-lisp
      (electric-indent-mode 1)

      ;; ignore for python
      (defun electric-indent-ignore-python (char)
        "Ignore Electric Indent for Python, CHAR is ignored."
        (if (or
             (equal major-mode 'python-mode)
             (equal major-mode 'markdown-mode)
             (equal major-mode 'makefile-gmake-mode)
             (equal major-mode 'org-mode)
             (equal major-mode 'org-journal-mode))
            `no-indent'
          t))
      (add-to-list 'electric-indent-functions 'electric-indent-ignore-python)
    #+END_SRC

    For python and markdown, indent when entering new line

    #+BEGIN_SRC emacs-lisp
      (defun set-newline-and-indent ()
        "Map RET key to `newline-and-indent'."
        (local-set-key (kbd "RET") 'newline-and-indent))
      (add-hook 'python-mode-hook 'set-newline-and-indent)
      (add-hook 'markdown-mode-hook 'set-newline-and-indent)
    #+END_SRC

*** Line opening

    Set up line opening shorcuts, one for opening above, another for
    below


    #+BEGIN_SRC emacs-lisp
      (defvar newline-and-indent t "Make line openings use auto indent.")

      (defun open-next-line (count)
              "Open COUNT lines after the current one.

      See also `newline-and-indent'."
              (interactive "p")
              (end-of-line)
              (open-line count)
              (forward-line count)
              (when newline-and-indent
                (indent-according-to-mode)))
      ;; Behave like vi's O command
      (defun open-previous-line (count)
              "Open COUNT new line before the current one.

      See also `newline-and-indent'."
              (interactive "p")
              (beginning-of-line)
              (open-line count)
              (when newline-and-indent
                (indent-according-to-mode)))

      (global-set-key (kbd "C-o") 'open-next-line)
      (global-set-key (kbd "M-o") 'open-previous-line)
    #+END_SRC

*** Show Matching Brackets

    Show matching brackets (and parentheses, but these get more later
    on)


    #+BEGIN_SRC emacs-lisp
      (show-paren-mode)
    #+END_SRC

** Utility Functions

   A function to get files in a directory recursively, this is used in
   the ~org-agenda~ config to add all the files in ~$HOME/org/agenda~
   and it's subfolders

   #+BEGIN_SRC emacs-lisp
     (defun directory-files-recursive(directory &optional match)
       "Get all files in DIRECTORY recursivley.
     There are three optional arguments:
     If FULL is non-nil, return absolute file names.  Otherwise return names
      that are relative to the specified directory.
     If MATCH is non-nil, mention only file names that match the regexp MATCH.
     If NOSORT is non-nil, the list is not sorted--its order is unpredictable.
      Otherwise, the list returned is sorted with `string-lessp'.
      NOSORT is useful if you plan to sort the result yourself."
       (interactive)
       (let (file-list
             (current-dir-list (directory-files-and-attributes directory t))
             (match (if match match "^[^.].*"))) ; ignore hidden files by default
         (while current-dir-list
           (let ((file-name (car (car current-dir-list)))
                 (is-dir (equal t (car (cdr (car current-dir-list))))))
             (cond
              ;; if the filename matches the match string
              (is-dir
               ;; make sure it is not a hidden dir
               (if (or
                    (equal "." (substring file-name -1))
                    (equal "." (substring (file-name-nondirectory file-name) 0 1)))
                   ()
                 ;; recurse it adding the result to the list
                 (setq file-list
                       (append
                        (directory-files-recursive file-name match)
                        file-list))))
              ((string-match match (file-name-nondirectory file-name))
               (setq file-list (cons file-name file-list)))))
           (setq current-dir-list (cdr current-dir-list)))
         file-list))
   #+END_SRC


   A function to indent the entire buffer, bound to ~C-\~

   #+BEGIN_SRC emacs-lisp
     (defun indent-buffer ()
       "Indent entire buffer using `indent-according-to-mode'."
       (interactive)
       (save-excursion
         (push-mark (point))
         (push-mark (point-max) nil t)
         (goto-char (point-min))
         (indent-region (region-beginning) (region-end))))
     (global-set-key (kbd "C-c \\") 'indent-buffer)
   #+END_SRC

   A function that makes a variable local to the buffer and sets it's
   value in one step


   #+BEGIN_SRC emacs-lisp
     (defun set-local-variable (varname value)
       "Make a variable VARNAME local to the buffer if needed, then set to VALUE."
       (interactive "vVariable Name: \nsNew Value: ")
       (let  ((number (string-to-number value)))
         (make-variable-buffer-local varname)
         (if (and (= 0 number) (not (string-equal "0" value)))
             (set-variable varname value)
           (set-variable varname number))))
   #+END_SRC


* Basic Packages

** Zenburn

   Set the alist first so that we can override some color they use in
   the theme, namely a darker background and added shades

   Then set up the configuration for the theme, mostly custom colors
   for various other packages and the header/footer lines

   #+BEGIN_SRC emacs-lisp
     (use-package zenburn-theme
       :ensure t
       :demand
       :init
       (defvar zenburn-colors-alist
         '(("zenburn-fg+1"     . "#FFFFEF")
           ("zenburn-fg"       . "#DCDCCC")
           ("zenburn-fg-1"     . "#656555")
           ("zenburn-bg-2"     . "#000000")
           ("zenburn-bg-1"     . "#0C0C0C")
           ("zenburn-bg-05"    . "#121212")
           ("zenburn-bg"       . "#1C1C1C")
           ("zenburn-bg+05"    . "#222222")
           ("zenburn-bg+1"     . "#2C2C2C")
           ("zenburn-bg+2"     . "#3C3C3C")
           ("zenburn-bg+3"     . "#4C4C4C")
           ("zenburn-red+1"    . "#DCA3A3")
           ("zenburn-red"      . "#CC9393")
           ("zenburn-red-1"    . "#BC8383")
           ("zenburn-red-2"    . "#AC7373")
           ("zenburn-red-3"    . "#9C6363")
           ("zenburn-red-4"    . "#8C5353")
           ("zenburn-orange"   . "#DFAF8F")
           ("zenburn-yellow"   . "#F0DFAF")
           ("zenburn-yellow-1" . "#E0CF9F")
           ("zenburn-yellow-2" . "#D0BF8F")
           ("zenburn-yellow-4" . "#B09F6F")
           ("zenburn-green-2"  . "#4F6F4F")
           ("zenburn-green-1"  . "#5F7F5F")
           ("zenburn-green"    . "#7F9F7F")
           ("zenburn-green+1"  . "#8FB28F")
           ("zenburn-green+2"  . "#9FC59F")
           ("zenburn-green+3"  . "#AFD8AF")
           ("zenburn-green+4"  . "#BFEBBF")
           ("zenburn-cyan"     . "#93E0E3")
           ("zenburn-blue+1"   . "#94BFF3")
           ("zenburn-blue"     . "#8CD0D3")
           ("zenburn-blue-1"   . "#7CB8BB")
           ("zenburn-blue-2"   . "#6CA0A3")
           ("zenburn-blue-3"   . "#5C888B")
           ("zenburn-blue-4"   . "#4C7073")
           ("zenburn-blue-5"   . "#366060")
           ("zenburn-magenta"  . "#DC8CC3"))
         "List of Zenburn colors.
     Each element has the form (NAME . HEX).

     `+N' suffixes indicate a color is lighter.
     `-N' suffixes indicate a color is darker.

     This overrides the colors provided by the `zenburn-theme' package.")


       :config
       (load-theme 'zenburn t)


       ;; default face customizations
       (zenburn-with-color-variables
         ;; darker region selection
         (set-face-attribute 'region nil :background zenburn-bg-2)
         ;; flat mode and header lines
         (set-face-attribute 'header-line nil :background zenburn-bg+1 :box nil)
         (set-face-attribute 'mode-line nil :background zenburn-bg+1 :box nil)
         (set-face-attribute 'mode-line-inactive nil :foreground zenburn-bg+3 :background zenburn-bg+05 :box nil)
         ;; italic comments
         (set-face-attribute 'font-lock-comment-face nil :slant 'italic)
         ;; set the verticle border color
         (set-face-attribute 'vertical-border nil :foreground zenburn-bg-1))

       ;; powerline colors
       (with-eval-after-load 'powerline
         (zenburn-with-color-variables
           (set-face-attribute 'powerline-active1 nil :background zenburn-bg+05 :foreground zenburn-green+1)
           (set-face-attribute 'powerline-active2 nil :background zenburn-bg+1 :foreground zenburn-green+1)
           (set-face-attribute 'powerline-inactive1 nil :background zenburn-bg+05 :foreground zenburn-bg+3)
           (set-face-attribute 'powerline-inactive2 nil :background zenburn-bg+05 :foreground zenburn-bg+3)))

       ;; flycheck use straight underline instead of wave
       (with-eval-after-load 'flycheck
         (zenburn-with-color-variables
           (set-face-attribute 'flycheck-error nil :underline `(:style line :color ,zenburn-red-1))
           (set-face-attribute 'flycheck-warning nil :underline `(:style line :color ,zenburn-yellow-2))
           (set-face-attribute 'flycheck-info nil :underline `(:style line :color ,zenburn-blue-2))))

       ;; helm faces
       (with-eval-after-load 'helm
         (zenburn-with-color-variables
           (set-face-attribute 'helm-source-header nil :background zenburn-bg+2 :height 1.3 :box '(:style nil))
           (set-face-attribute 'helm-selection nil :background zenburn-bg+2 :weight 'bold)))
       (with-eval-after-load 'helm-utils
         (zenburn-with-color-variables
           (set-face-attribute 'helm-selection-line nil :background zenburn-bg+2)))

       ;; company faces
       (with-eval-after-load 'company
         (zenburn-with-color-variables
           (set-face-attribute 'company-preview nil :background zenburn-green+2 :foreground zenburn-bg)
           (set-face-attribute 'company-preview-search nil :background zenburn-blue :foreground zenburn-bg)))

       (with-eval-after-load 'company-template
         (zenburn-with-color-variables
           (set-face-attribute 'company-template-field nil :background zenburn-yellow-1 :foreground zenburn-bg)))

       ;; faces for ledger mode
       (with-eval-after-load 'ledger-mode
         (zenburn-with-color-variables
           (set-face-attribute 'ledger-font-auto-xact-face nil :foreground zenburn-yellow)
           (set-face-attribute 'ledger-font-periodic-xact-face nil :foreground zenburn-green+3)
           (set-face-attribute 'ledger-font-xact-cleared-face nil :foreground zenburn-fg)
           (set-face-attribute 'ledger-font-xact-pending-face nil :foreground zenburn-yellow-2)
           ;; (set-face-attribute 'ledger-font-xact-open-face nil :foreground zenburn-bg-1)
           (set-face-attribute 'ledger-font-payee-uncleared-face nil :foreground zenburn-fg-1)
           (set-face-attribute 'ledger-font-payee-pending-face nil :foreground zenburn-yellow-2)
           (set-face-attribute 'ledger-font-pending-face nil :foreground zenburn-yellow-2)
           (set-face-attribute 'ledger-font-other-face nil :foreground zenburn-blue-1)
           (set-face-attribute 'ledger-font-posting-account-face nil :foreground zenburn-blue-3 )
           (set-face-attribute 'ledger-font-posting-amount-face nil :foreground zenburn-green+4 )
           (set-face-attribute 'ledger-font-posting-date-face nil :foreground zenburn-orange :underline t)
           (set-face-attribute 'ledger-font-report-clickable-face nil :foreground zenburn-fg+1)))

       ;; highlight-parentheses
       (with-eval-after-load 'highlight-parentheses
         (zenburn-with-color-variables
           (setq hl-paren-background-colors `(,zenburn-bg-2 ,zenburn-bg-1 ,zenburn-bg-05 ,zenburn-bg+05 ,zenburn-bg+1 ,zenburn-bg+2 ,zenburn-bg+3 ,zenburn-fg-1))
           (setq hl-paren-colors `(,zenburn-red-2 ,zenburn-green ,zenburn-orange ,zenburn-blue ,zenburn-yellow ,zenburn-cyan ,zenburn-magenta ,zenburn-fg+1))))



       ;; faces for avy
       (with-eval-after-load 'avy
         (zenburn-with-color-variables
           (set-face-attribute 'avy-background-face nil :foreground zenburn-fg-1 :background zenburn-bg-1)
           (set-face-attribute 'avy-lead-face-0 nil :foreground zenburn-fg+1 :background zenburn-blue-5)
           (set-face-attribute 'avy-lead-face-1 nil :foreground zenburn-fg+1 :background zenburn-bg-2)
           (set-face-attribute 'avy-lead-face-2 nil :foreground zenburn-fg+1 :background zenburn-blue-4)
           (set-face-attribute 'avy-lead-face nil :foreground zenburn-fg+1 :background zenburn-red-4))))
   #+END_SRC

** Autorevert

   #+BEGIN_SRC emacs-lisp
     (use-package autorevert
       :diminish auto-revert-mode
       :config
       (global-auto-revert-mode))
   #+END_SRC

** Highlight Parentheses

   Enabled just for elisp right now, others if needed

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-parentheses
       :ensure t
       :diminish highlight-parentheses-mode
       :config
       (add-hook 'emacs-lisp-mode-hook
               '(lambda ()
                  (highlight-parentheses-mode))))
   #+END_SRC

** Subword

   #+BEGIN_SRC emacs-lisp
     (use-package subword
       :diminish subword-mode
       :config
       (global-subword-mode))
   #+END_SRC

** Adaptive Wrap
    
   #+BEGIN_SRC emacs-lisp
     (use-package adaptive-wrap
       :ensure t
       :pin gnu
       :init
       (defvar adaptive-wrap-extra-indent 2)
       :config
       (add-hook 'visual-line-mode-hook
                 '(lambda ()
                    (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))))

   #+END_SRC
    
** Relative Line Numbers

   #+BEGIN_SRC emacs-lisp
     (use-package linum-relative
       :ensure t
       :pin melpa-stable
       :bind (("C-x l" . linum-relative-toggle))
       :diminish linum-relative-mode
       :demand
       :init
       (defvar linum-relative-current-symbol "")
       (defvar linum-relative-format "%3s ")
       :config
       (add-hook 'prog-mode-hook #'linum-relative-mode))

   #+END_SRC
** Dired

   #+BEGIN_SRC emacs-lisp
     (use-package dired
       :config
       (setq dired-listing-switches "-lha --group-directories-first"))
   #+END_SRC

** Uniquify

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :config
       (customize-set-variable 'uniquify-buffer-name-style 'forward))
   #+END_SRC

** Magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :pin melpa-stable
       :config
       (setq magit-merge-arguments '("--no-ff"))

       (defvar my-git-command-map
         (let ((map (make-sparse-keymap)))
           (define-key map "g" 'magit-status)
           (define-key map (kbd "C-g") 'magit-status)
           (define-key map "l" 'magit-log)
           (define-key map "f" 'magit-fetch-current)
           (define-key map "h" 'helm-git-files)
           (define-key map "!" 'magit-blame-mode)
           (define-key map "c" 'magit-checkout)
           (define-key map (kbd "C-r") 'magit-rebase-step)
           (define-key map (kbd "C-f") 'magit-pull)
           (define-key map (kbd "C-p") 'magit-push)
           (define-key map (kbd "z z") 'magit-stash)
           (define-key map (kbd "z p") 'magit-stash-pop)
           (define-key map (kbd "C-t") 'git-timemachine)
           (define-key map (kbd "C-c") 'magit-create-branch)
           map)
         "Keymap of commands to load magit.")

       (define-key global-map (kbd "C-c g") my-git-command-map)
       (define-key global-map (kbd "C-c C-g") my-git-command-map))
   #+END_SRC

** Helm

   #+BEGIN_SRC emacs-lisp
     (use-package helm
       :ensure t
       :pin melpa-stable
       :diminish helm-mode
       :bind (("C-c h" . helm-command-prefix)
              ("M-x" . helm-M-x)
              ("M-y" . helm-show-kill-ring)
              ("C-x b" . helm-mini)
              ("C-x C-b" . helm-mini)
              ("C-x C-f" . helm-find-files)
              :map helm-map
              (([tab] . helm-execute-persistent-action)
               "C-z" . helm-select-action))
       :config
       (when (executable-find "curl")
         (setq helm-net-prefer-curl t))

       (setq helm-quick-update                     t ; do not display invisible candidates
             helm-split-window-in-side-p           t ; open helm buffer inside current window, not occupy whole other window
             helm-buffers-fuzzy-matching           t ; fuzzy matching buffer names when non--nil
             helm-M-x-fuzzy-match                  t ; fuzzy match M-x
             helm-recentf-fuzzy-match              t ; fuzzy match recent files
             helm-bookmark-show-location           t
             helm-completion-in-region-fuzzy-match t
             helm-file-cache-fuzzy-match           t
             helm-imenu-fuzzy-match                t
             helm-mode-fuzzy-match                 t
             helm-locate-fuzzy-match               t
             helm-quick-update                     t
             helm-semantic-fuzzy-match             t
             helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
             helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
             helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
             helm-ff-file-name-history-use-recentf t)

       (setq helm-split-window-in-side-p t)
       (setq helm-autoresize-max-height 25)
       (setq helm-autoresize-min-height 25)

       (helm-mode 1))

   #+END_SRC



   Add in ~flx~ for fuzzy matching

   #+BEGIN_SRC emacs-lisp
     (use-package flx
       :ensure t
       :pin melpa-stable
       :config
       (with-eval-after-load 'helm
         ;; this is a bit hackish, ATM, redefining functions I don't own
         (defvar helm-flx-cache (flx-make-string-cache #'flx-get-heatmap-str))

         (defun helm-score-candidate-for-pattern (candidate pattern)
           (or (car (flx-score candidate pattern helm-flx-cache)) 0))

         (defun helm-fuzzy-default-highlight-match (candidate)
           (let* ((pair (and (consp candidate) candidate))
                  (display (if pair (car pair) candidate))
                  (real (cdr pair)))
             (with-temp-buffer
               (insert display)
               (goto-char (point-min))
               (if (string-match-p " " helm-pattern)
                   (cl-loop with pattern = (split-string helm-pattern)
                            for p in pattern
                            do (when (search-forward p nil t)
                                 (add-text-properties
                                  (match-beginning 0) (match-end 0) '(face helm-match))))
                 (cl-loop with pattern = (cdr (flx-score display
                                                         helm-pattern helm-flx-cache))
                          for index in pattern
                          do (add-text-properties
                              (1+ index) (+ 2 index) '(face helm-match))))
               (setq display (buffer-string)))
             (if real (cons display real) display)))))
   #+END_SRC

** Org

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure org-plus-contrib
       :mode (("\\.org$" . org-mode))
       :pin org
       :init
       (defvar org-directory "~/org" "Directory for org files.")
       (defvar org-agenda-directory "~/org/agenda" "Directory for org files.")
       (defvar org-mobile-directory "~/.org-mobile" "Directory for mobile org files.")
       (defvar org-time-clocksum-format "%d:%.02d")
       (setq org-journal-dir (concat org-directory "/journal/"))
       :config
       (condition-case nil
           (make-directory org-journal-dir t) ; make the org and journal dirs if they are not there already
         (error nil))
       (condition-case nil
           (make-directory org-mobile-directory t) ; make the org and journal dirs if they are not there already
         (error nil))

       (defun org-agenda-reload ()
         "Reset org agenda files by rescanning the org directory."
         (interactive)
         (setq org-agenda-files (directory-files-recursive org-agenda-directory "\\.org\\|[0-9]\\{8\\}"))
         (setq org-refile-targets '((org-agenda-files . (:level . 1)))))

       (org-agenda-reload)
       (setq org-agenda-file-regexp "\\([^.].*\\.org\\)\\|\\([0-9]+\\)")

       (setq org-log-done 'time)
       (setq org-enforce-todo-dependencies t)
       (setq org-agenda-dim-blocked-tasks t)
       (setq org-catch-invisible-edits t)

       (setq org-clock-idle-time 15)
       (setq org-clock-mode-line-total 'current)
       (setq org-log-into-drawer "LOGBOOK")
       (setq org-clock-into-drawer "LOGBOOK")
       (setq org-time-clocksum-use-fractional t)

       (setq org-todo-keywords
             '((sequence "TODO(t)" "IN-PROGRESS(i!)" "WAITING(w@)" "|" "WILL-NOT-IMPLEMENT(k@)" "DONE(d)")
               (sequence "BUG(b)" "RESOLVING(r!)" "|" "NON-ISSUE(n@)" "PATCHED(p)")))

       ;; defaut capture file
       (setq org-default-notes-file (concat org-directory "/todo.org"))

       (setq org-capture-templates
             '(("t" "Todo" entry (file+headline (concat org-directory "/todo.org") "Todo") "* TODO %?\n  SCHEDULED: %^{Schedule}t\n  %A")
               ("n" "Note" entry (file+headline (concat org-directory "/notes.org") "Notes") "* %? %U\n  %i")))

       (add-hook 'org-mode-hook
                 (lambda ()
                   (add-hook 'after-save-hook 'org-babel-tangle nil 'local-please)))

       (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0_10.jar")
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((sh . t)
          (ditaa . t)))

       ;; expand logbook on org all expand
       (defun ds/expand-logbook-drawer ()
         "Expand the closest logbook drawer."
         (interactive)
         (search-forward ":LOGBOOK:")
         (org-cycle))

       (defun ds/org-logbook-cycle-hook (ds/drawer-curr-state)
         "When the MY/VAR/CURR-STATE is \"all\", open up logbooks."
         (interactive)
         (message "State changed")
         (when (eq ds/drawer-curr-state "all")
           (ds/expand-logbook-drawer)))

       (add-hook 'org-cycle-hook 'ds/org-logbook-cycle-hook))


   #+END_SRC

** Projectile

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :pin melpa-stable
       :bind (:map projectile-command-map
                   ("s s" . helm-projectile-ag))
       :init
       (defvar projectile-remember-window-configs t)
       :config
       (projectile-global-mode))
   #+END_SRC

   Add the extension to use helm

   #+BEGIN_SRC emacs-lisp
     (use-package helm-projectile
       :ensure t 
       :pin melpa-stable
       :config
       (helm-projectile-toggle 1)
       (setq helm-projectile-fuzzy-match t))

   #+END_SRC
    
   Then add ~helm-ag~ so you can use ~the_silver_searcher~ across all
   the project files

   #+BEGIN_SRC emacs-lisp
     (use-package helm-ag
       :ensure t
       :pin melpa-stable)
   #+END_SRC
    
** Multiple Cursors

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :pin melpa-stable
       :bind (("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)))
   #+END_SRC

** Undo Tree

   More "sane" undo/redo system

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :pin gnu
       :diminish undo-tree-mode
       :config
       (global-undo-tree-mode))
   #+END_SRC







* Programming Packages

** Flycheck

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :pin melpa-stable
       :diminish flycheck-mode
       :init
       (setq-default flycheck-emacs-lisp-load-path 'inherit)
       :config
       ;; enable flycheck everywhere
       (add-hook 'after-init-hook #'global-flycheck-mode))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-pos-tip
       :ensure t
       :pin melpa-stable
       :config
       (with-eval-after-load 'flycheck
       (flycheck-pos-tip-mode)))
   #+END_SRC

   The mode line coloring is disabled for now

   #+BEGIN_SRC emacs-lisp :tangle no
     (use-package flycheck-color-mode-line
       :ensure t
       :pin melpa-stable
       :init
       (defface flycheck-color-mode-line-error-face
         '((t))
         "Face for the modeline in buffers with Flycheck errors."
         :group 'flycheck-faces)

       (defface flycheck-color-mode-line-warning-face
         '((t))
         "Face for the modeline in buffers with only Flycheck warnings."
         :group 'flycheck-faces)

       (defface flycheck-color-mode-line-info-face
         '((t))
         "Face for the modeline in buffers with only Flycheck info."
         :group 'flycheck-faces)
       :config
       (eval-after-load 'flycheck
         '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
   #+END_SRC

** Completion
   
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :pin melpa-stable
       :diminish company-mode
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-tooltip-limit 20) ; bigger popup window
       (setq company-idle-delay .4)    ; decrease delay before autocompletion popup shows
       (setq company-echo-delay 0))    ; remove annoying blinking
   #+END_SRC
   
** Commenter

   Originally for evil, but works great for vanilla

   #+BEGIN_SRC emacs-lisp
     (use-package evil-nerd-commenter
       :ensure t
       :pin melpa-stable
       :bind (("C-c C-/ C-/" . evilnc-comment-or-uncomment-lines)
              ("C-c C-/ C-l" . evilnc-comment-or-uncomment-to-the-line)
              ("C-c C-/ C-c" . evilnc-copy-and-comment-lines)
              ("C-c C-/ C-p" . evilnc-comment-or-uncomment-paragraphs)))
   #+END_SRC

** Rust

   #+BEGIN_SRC emacs-lisp
     (use-package rust-mode
       :ensure t
       :pin melpa-stable
       :config
       (add-to-list 'auto-mode-alist '("\\.rs\\'" . rust-mode))
       (add-hook 'rust-mode-hook
                 '(lambda ()
                    (rust-enable-format-on-save))))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (use-package racer
       :ensure t
       :diminish racer-mode
       :config
       (add-hook 'rust-mode-hook #'racer-mode)
       (add-hook 'racer-mode-hook #'eldoc-mode)
       (add-hook 'racer-mode-hook  #'company-mode)
       (setq company-tooltip-align-annotations t)
       (local-set-key (kbd "TAB") #'company-indent-or-complete-common))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-rust
       :ensure t
       :config
       (add-hook 'flycheck-mode-hook #'flycheck-rust-setup))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (use-package rust-playground
       :ensure t)
   #+END_SRC

** Golang

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :ensure t
       :pin melpa-stable
       :config
       (defun my-go-hook ()
         "Hook for go-mode."
         ;; call gofmt for every save
         (add-hook 'before-save-hook 'gofmt-before-save)
         ;; customize the compile command
         (if (not (string-match "go" compile-command))
             (set (make-local-variable 'compile-command)
                  "go build -v && go test && go vet")))

       (add-hook 'go-mode-hook 'my-go-hook))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package go-eldoc
       :ensure t
       :pin melpa-stable
       :config
       (add-hook 'go-mode-hook 'go-eldoc-setup)

       (set-face-attribute 'eldoc-highlight-function-argument nil
                           :foreground "blue"
                           :weight 'bold))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (use-package go-scratch
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package company-go
       :ensure t
       :config
       (setq company-go-insert-arguments nil)
       (add-hook 'go-mode-hook (lambda ()
                                 (set (make-local-variable 'company-backends) '(company-go))
                                 (company-mode))))
   #+END_SRC

   
* Applications

  Packages that are sort of "apps" on their own or interact with other
  system apps, outside of the "development" scope

** ZNC

   Connects to a ZNC server, used for persistant IRC presence and
   history playback.

   Config is done through the main config interface, saves it into
   ~custom.el~, which is not tracked.

   #+BEGIN_SRC emacs-lisp
     (use-package znc
       :ensure t
       :defer t)
   #+END_SRC


** Ledger

   The best accounting app out there

   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :ensure t
       :config
       (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
       (add-to-list 'auto-mode-alist '("\\.ldg$" . ledger-mode))
       (add-to-list 'auto-mode-alist '("\\.rec$" . ledger-mode))

       (org-babel-do-load-languages
        'org-babel-load-languages
        '((ledger . t)))

       (defun find-ledger-directory ()
         "Get directory with ledger files."
         (let ((ledgerrc (concat (getenv "HOME") "/.ledgerrc")))
           (if (file-readable-p ledgerrc)
               (let ((conffile (with-temp-buffer
                                 (insert-file-contents ledgerrc)
                                 (split-string (buffer-string) "\n")))
                     (filename ""))
                 (dolist (ln conffile filename)
                   (message ln)
                   (if (string-match "^--file" ln)
                       (setq filename (replace-regexp-in-string "^--file \\([[:graph:]]\+\\)" "\\1" ln))
                     nil))
                 (string-trim (shell-command-to-string
                               (concat
                                "dirname "
                                filename)))))))

       (defun look-for-ledger-schedule-file ()
         "See if there is a file in the same directory as this ledger file with the same basename and a \".rec\" extenxtion. If so, set the `ledger-schedule-file variable' to this file for the local buffer."
         (if (not (string= (buffer-name) ledger-schedule-buffer-name))
             (set-local-variable
              'ledger-schedule-file
              (replace-regexp-in-string
               "\\.\\(ledger\\|ldg\\)" ".rec" (buffer-file-name) nil 'literal))))

       (add-hook 'ledger-mode-hook #'look-for-ledger-schedule-file)


       (defun org-to-tc ()
         "Convert the current org file into a timeclock file for ledger."
         (message "Saving timeclock file")
         (let ((cmdstr (concat "~/.emacs.d/bin/org2tc "
                               (buffer-file-name)
                               " > " (find-ledger-directory) "/"
                               (replace-regexp-in-string
                                (regexp-quote "\.org") ".timeclock" (buffer-name) nil 'literal))))
           (message cmdstr)
           (shell-command cmdstr)))


       (add-hook 'org-mode-hook
                 (lambda ()
                   (add-hook 'after-save-hook 'org-to-tc nil 'local-please)))

       (setq ledger-reports
             '(("asset/liabilities" "ledger -f %(ledger-file) bal assets liabilities")
               ("profit/loss" "ledger -f %(ledger-file) bal income expenses")
               ("checkbook" "ledger -f %(ledger-file) reg personal:assets:checking")
               ("cc" "ledger -f %(ledger-file) reg personal:liabilities and visa")
               ("loans" "ledger -f %(ledger-file) reg personal:liabilities and loan personal:expense and loan")
               ("bal" "ledger -f %(ledger-file) bal")
               ("reg" "ledger -f %(ledger-file) reg")
               ("payee" "ledger -f %(ledger-file) reg @%(payee)")
               ("account" "ledger -f %(ledger-file) reg %(account)"))))
   #+END_SRC


* Bootstrap

  ;; Local Variables:
  ;; eval: (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t)
  ;; End:

