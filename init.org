#+TITLE: emacs config
#+AUTHOR: Paul Davis
#+BABEL: :cache yes
#+LATEX_HEADER: \usepackage{parskip}
#+LATEX_HEADER: \usepackage{inconsolata}
#+LATEX_HEADER: \usepackage[utf8]{inputenc}
#+PROPERTY: header-args :tangle yes

* Setup

  To get this configuration working, clone the repo to
  ~$HOME/.emacs.d~ and open emacs. It will be the default
  configuration. Open up the file at ~$HOME/.emacs.d/init.org~.

  You will be prompted to execute the lisp in the file. Select the ~Y~
  option to run it once. This will tangle all of the blocks into the
  ~init.el~ file. After this is completed, exit emacs and reopen it.

  Open the ~init.org~ file again, and this time choose the ~!~ option
  to save the preference to run the embedded elisp. From now on, when
  you save the ~init.org~ file, the ~init.el~ file will be tangled and
  compiled.

  
* Configuration

** Init

   First, make sure this file will compile itself into a ~.el~ file
   that emacs can load. The repo's existing ~init.el~ will bootstrap
   this and replace itself in the process

   #+BEGIN_SRC emacs-lisp
     (defun ds/tangle-init ()
       "If the current buffer is 'init.org' the code-blocks are
     tangled, and the tangled file is compiled."
       (when (equal (buffer-file-name)
                    (expand-file-name (concat user-emacs-directory "init.org")))
         ;; Avoid running hooks when tangling.
         (let ((prog-mode-hook nil))
           (org-babel-tangle)
           (byte-compile-file (concat user-emacs-directory "init.el")))))

     (add-hook 'after-save-hook 'ds/tangle-init)
   #+END_SRC

   Inhibit the startup message

   #+BEGIN_SRC emacs-lisp
     (setq inhibit-startup-message t)
   #+END_SRC

   Set up package repos and ~use-package~

   #+BEGIN_SRC emacs-lisp
     (require 'package)
     (setq package-enable-at-startup nil)
     (setq package-archives
           '(("melpa"        . "http://melpa.org/packages/")
             ("melpa-stable" . "http://stable.melpa.org/packages/")
             ("gnu"          . "http://elpa.gnu.org/packages/")
             ("org"          . "http://orgmode.org/elpa/"))
           package-archive-priorities
           '(("org"          . 20)
             ("melpa-stable" . 15)
             ("gnu"          . 10)
             ("melpa"        . 0)))

     (setq package-pinned-packages '((use-package . "melpa")))

     (package-initialize)

     (unless (package-installed-p 'use-package)
       (package-refresh-contents)
       (package-install 'use-package))

     (eval-when-compile
       (require 'use-package))
     ;; use-package should have these loaded
     (require 'diminish)
     (require 'bind-key)
   #+END_SRC

   Disable lock files

   #+BEGIN_SRC emacs-lisp
     (setq-default create-lockfiles nil)
   #+END_SRC

   Adjust backup file settings to be in a separate directory

   #+BEGIN_SRC emacs-lisp
     (defvar ds/backup-directory
       (expand-file-name "tmp/backups" user-emacs-directory)
       "Where backups go.")
     (defvar ds/autosave-directory
       (expand-file-name "tmp/autosave" user-emacs-directory)
       "Where autosaves go.")
     (make-directory ds/backup-directory t)
     (make-directory ds/autosave-directory  t)
     (setq backup-by-copying t
           backup-directory-alist `((".*" .  ,ds/backup-directory))
           auto-save-file-name-transforms `((".*"  ,ds/autosave-directory t))
           auto-save-list-file-prefix  ds/autosave-directory
           delete-old-versions t
           kept-new-versions 6
           kept-old-versions 2
           version-control t)
   #+END_SRC

   Remove menu bars and scroll bars

   #+BEGIN_SRC emacs-lisp
     (menu-bar-mode -1)
     (tool-bar-mode -1)
     (scroll-bar-mode -1)
   #+END_SRC

   Set the font

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'default-frame-alist '(font . "Ubuntu Mono-10"))
   #+END_SRC

   Setup custom file

   #+BEGIN_SRC emacs-lisp
     (defvar custom-file-location
       (expand-file-name "custom.el" user-emacs-directory)
       "File for customizations via \\[customize].")

     (setq custom-file custom-file-location)
     (if (file-readable-p custom-file-location)
         (progn
           (load custom-file)))
   #+END_SRC

** Basic Customizations
*** Indentation

    Fuck tabs

    #+BEGIN_SRC emacs-lisp
      (setq-default indent-tabs-mode nil)
      (setq-default tab-width 4)
      (setq-default tab-stop-list (number-sequence 4 120 4))
    #+END_SRC

    Setup electric indent

    #+BEGIN_SRC emacs-lisp
      (electric-indent-mode 1)

      ;; ignore for python
      (defun electric-indent-ignore-python (char)
        "Ignore Electric Indent for Python, CHAR is ignored."
        (if (or
             (equal major-mode 'python-mode)
             (equal major-mode 'markdown-mode)
             (equal major-mode 'makefile-gmake-mode)
             (equal major-mode 'org-mode)
             (equal major-mode 'org-journal-mode))
            `no-indent'
          t))
      (add-to-list 'electric-indent-functions 'electric-indent-ignore-python)
    #+END_SRC

    For python and markdown, indent when entering new line

    #+BEGIN_SRC emacs-lisp
      (defun set-newline-and-indent ()
        "Map RET key to `newline-and-indent'."
        (local-set-key (kbd "RET") 'newline-and-indent))
      (add-hook 'python-mode-hook 'set-newline-and-indent)
      (add-hook 'markdown-mode-hook 'set-newline-and-indent)
    #+END_SRC

*** Line opening

    Set up line opening shorcuts, one for opening above, another for
    below


    #+BEGIN_SRC emacs-lisp
      (defvar newline-and-indent t "Make line openings use auto indent.")

      (defun open-next-line (count)
              "Open COUNT lines after the current one.

      See also `newline-and-indent'."
              (interactive "p")
              (end-of-line)
              (open-line count)
              (forward-line count)
              (when newline-and-indent
                (indent-according-to-mode)))
      ;; Behave like vi's O command
      (defun open-previous-line (count)
              "Open COUNT new line before the current one.

      See also `newline-and-indent'."
              (interactive "p")
              (beginning-of-line)
              (open-line count)
              (when newline-and-indent
                (indent-according-to-mode)))

      (global-set-key (kbd "C-o") 'open-next-line)
      (global-set-key (kbd "M-o") 'open-previous-line)
    #+END_SRC

*** Show Matching Brackets

    Show matching brackets (and parentheses, but these get more later
    on)


    #+BEGIN_SRC emacs-lisp
      (show-paren-mode)
    #+END_SRC

*** Enable Commands

    #+BEGIN_SRC emacs-lisp
      (put 'narrow-to-region 'disabled nil)
    #+END_SRC

*** ERC
    #+BEGIN_SRC emacs-lisp
      (defvar erc-hide-list '("JOIN" "PART" "QUIT"))
    #+END_SRC

*** Compiling

    Close compilation windows after 2 seconds if they are successful

    #+BEGIN_SRC emacs-lisp
      (setq compilation-finish-functions
            '((lambda (buf str)
                (if (null (string-match ".*exited abnormally.*" str))
                    ;;no errors, make the compilation window go away in a few seconds
                    (progn
                      (run-at-time
                       "2 sec" nil 'delete-windows-on
                       (get-buffer-create "*compilation*"))
                      (message "No Compilation Errors!"))))))
    #+END_SRC

    Make compile window auto-scroll

    #+BEGIN_SRC emacs-lisp
      (setq compilation-scroll-output t)
    #+END_SRC

*** Eshell

    Some settings to make eshell "nicer"

    #+BEGIN_SRC emacs-lisp
      (use-package eshell
        :config
        (defun ds/setup-eshell-autosuggest ()
          (with-eval-after-load 'company
            (setq-local company-backends '(company-eshell-autosuggest company-elisp))
            (setq-local company-idle-delay 0)))

        (with-eval-after-load 'company
          (add-hook 'eshell-mode-hook #'ds/setup-eshell-autosuggest))

        (setenv "PAGER" "cat")

        (setq eshell-scroll-to-bottom-on-input 'all
              eshell-error-if-no-glob t
              eshell-hist-ignoredups t
              eshell-save-history-on-exit t
              eshell-prefer-lisp-functions nil
              eshell-destroy-buffer-when-process-dies t)

        (add-hook 'eshell-mode-hook
                  (lambda ()
                    (add-to-list 'eshell-visual-commands "ssh")
                    (add-to-list 'eshell-visual-commands "tail")
                    (add-to-list 'eshell-visual-commands "top")
                    (zenburn-with-color-variables
                      (set-face-attribute 'eshell-prompt-face nil :foreground zenburn-fg :weight 'normal)))))
    #+END_SRC

    Prompt setup for eshell

    #+BEGIN_SRC emacs-lisp
      (use-package dash
        :ensure t
        :config
        (use-package s
          :ensure t
          :config
          (use-package eshell
            :init

            (defvar ds/eshell-sep " | "
              "Separator between esh-sections")

            (defvar ds/eshell-section-delim " "
              "Separator between an esh-section icon and form")

            (defvar ds/eshell-header "\n "
              "Eshell prompt header")

            (setq eshell-prompt-regexp "^ [$#] ")

            (defmacro ds/with-face (STR &rest PROPS)
              "Return STR propertized with PROPS."
              `(propertize ,STR 'face (list ,@PROPS)))

            (defmacro ds/eshell-section (NAME ICON FORM &rest PROPS)
              "Build eshell section NAME with ICON prepended to evaled FORM with PROPS."
              `(defvar ,NAME
                     (lambda () (when ,FORM
                                  (let ((result (concat ,ICON (if (> (length ,ICON) 0) ds/eshell-section-delim "") ,FORM)))
                                    (if ,@PROPS
                                        (ds/with-face result ,@PROPS)
                                      result))))
                     "Eshell prompt section - ,NAME"))


            (defun ds/split-directory-prompt (directory)
              (if (string-match-p ".*/.*" directory)
                  (list (file-name-directory directory) (file-name-base directory))
                (list "" directory)))

            (defun ds/pwd-shorten-dirs (pwd)
              "Shorten all directory names in PWD except the last two."
              (let ((p-lst (split-string pwd "/")))
                (if (> (length p-lst) 2)
                    (concat
                     (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                                (substring elm 0 1)))
                                (butlast p-lst 2)
                                "/")
                     "/"
                     (mapconcat (lambda (elm) elm)
                                (last p-lst 2)
                                "/"))
                  pwd)))  ;; Otherwise, we just return the PWD

            (ds/eshell-section esh-dir
                               (ds/with-face "" (zenburn-with-color-variables
                                                   `(:foreground ,zenburn-fg-1 :weight bold)))
                               (let* ((dirparts (ds/split-directory-prompt (ds/pwd-shorten-dirs (abbreviate-file-name (eshell/pwd)))))
                                      (parent (car dirparts))
                                      (dirname (cadr dirparts)))
                                 (concat (ds/with-face parent (zenburn-with-color-variables
                                                                `(:foreground ,zenburn-bg+3)))
                                         (ds/with-face dirname (zenburn-with-color-variables
                                                                 `(:foreground ,zenburn-fg-1 :weight bold))))))

            (ds/eshell-section esh-git
                               (ds/with-face ""
                                             (zenburn-with-color-variables `(:foreground ,zenburn-orange)))
                               (let* ((unstaged-count (length (magit-unstaged-files)))
                                      (staged-count (length (magit-staged-files)))
                                      (untracked-count (length (magit-untracked-files)))
                                      (unstaged (if (> unstaged-count 0)
                                                    (ds/with-face
                                                     (concat " (" (number-to-string unstaged-count) ")")
                                                     (zenburn-with-color-variables `(:foreground ,zenburn-yellow)))
                                                  ""))
                                      (staged (if (> staged-count 0)
                                                  (ds/with-face
                                                   (concat " (" (number-to-string staged-count) ")")
                                                   (zenburn-with-color-variables `(:foreground ,zenburn-green)))
                                                ""))
                                      (untracked (if (> untracked-count 0)
                                                     (ds/with-face
                                                      (concat " (" (number-to-string untracked-count) ")")
                                                      (zenburn-with-color-variables `(:foreground ,zenburn-red)))
                                                   "")))
                                 (if (magit-get-current-branch)
                                     (concat (ds/with-face (magit-get-current-branch)
                                                           (zenburn-with-color-variables `(:foreground ,zenburn-blue)))
                                             staged unstaged untracked)
                                   nil)))

            (set-fontset-font t '(#Xf017 . #Xf017) "fontawesome")

            (ds/eshell-section esh-clock
                               ""
                               (format-time-string "%H:%M" (current-time))
                               (zenburn-with-color-variables
                                 `(:foreground ,zenburn-green)))

            ;; Choose which eshell-funcs to enable
            (defvar ds/eshell-funcs (list (list esh-dir esh-clock) esh-git)
              "Eshell prompt sections")

            (defun ds/eshell-acc (acc x)
              "Accumulator for evaluating and concatenating esh-sections."
              (if (and (listp x) (not (functionp x)))
                  (concat acc (-reduce-from 'ds/eshell-acc "" x) "\n")
                (--if-let (funcall x)
                    (if (s-blank? acc)
                        it
                      (concat acc
                              (if (string= "\n" (substring acc (- (length acc) 1) (length acc)))
                                  " "
                                ds/eshell-sep)
                              it))
                  acc)))

            (defun ds/eshell-prompt-func ()
              "Build `eshell-prompt-function'"
              (concat ds/eshell-header
                      (replace-regexp-in-string "\n$" "" (-reduce-from 'ds/eshell-acc "" ds/eshell-funcs))
                      "\n"
                      (concat " " (if (= (user-uid) 0) "#" "$") " ")))

            ;; Enable the new eshell prompt
            (setq eshell-prompt-function 'ds/eshell-prompt-func)

            )))
    #+END_SRC

** Utility Functions

   A function to get files in a directory recursively, this is used in
   the ~org-agenda~ config to add all the files in ~$HOME/org/agenda~
   and it's subfolders

   #+BEGIN_SRC emacs-lisp
     (defun directory-files-recursive(directory &optional match)
       "Get all files in DIRECTORY recursivley.
     There are three optional arguments:
     If FULL is non-nil, return absolute file names.  Otherwise return names
      that are relative to the specified directory.
     If MATCH is non-nil, mention only file names that match the regexp MATCH.
     If NOSORT is non-nil, the list is not sorted--its order is unpredictable.
      Otherwise, the list returned is sorted with `string-lessp'.
      NOSORT is useful if you plan to sort the result yourself."
       (interactive)
       (let (file-list
             (current-dir-list (directory-files-and-attributes directory t))
             (match (if match match "^[^.].*"))) ; ignore hidden files by default
         (while current-dir-list
           (let ((file-name (car (car current-dir-list)))
                 (is-dir (equal t (car (cdr (car current-dir-list))))))
             (cond
              ;; if the filename matches the match string
              (is-dir
               ;; make sure it is not a hidden dir
               (if (or
                    (equal "." (substring file-name -1))
                    (equal "." (substring (file-name-nondirectory file-name) 0 1)))
                   ()
                 ;; recurse it adding the result to the list
                 (setq file-list
                       (append
                        (directory-files-recursive file-name match)
                        file-list))))
              ((string-match match (file-name-nondirectory file-name))
               (setq file-list (cons file-name file-list)))))
           (setq current-dir-list (cdr current-dir-list)))
         file-list))
   #+END_SRC


   A function to indent the entire buffer, bound to ~C-\~

   #+BEGIN_SRC emacs-lisp
     (defun indent-buffer ()
       "Indent entire buffer using `indent-according-to-mode'."
       (interactive)
       (save-excursion
         (push-mark (point))
         (push-mark (point-max) nil t)
         (goto-char (point-min))
         (indent-region (region-beginning) (region-end))))
     (global-set-key (kbd "C-c \\") 'indent-buffer)
   #+END_SRC

   A function that makes a variable local to the buffer and sets it's
   value in one step


   #+BEGIN_SRC emacs-lisp
     (defun set-local-variable (varname value)
       "Make a variable VARNAME local to the buffer if needed, then set to VALUE."
       (interactive "vVariable Name: \nsNew Value: ")
       (let  ((number (string-to-number value)))
         (make-variable-buffer-local varname)
         (if (and (= 0 number) (not (string-equal "0" value)))
             (set-variable varname value)
           (set-variable varname number))))
   #+END_SRC

   A function to toggle a serif font for a buffer, but still keep
   "code" in that buffer monospaced
   
   #+BEGIN_SRC emacs-lisp
     (defvar ds/serif-preserve-default-list nil
       "A list holding the faces that preserve the default family and height when TOGGLE-SERIF is used.")
     (defvar ds/preserve-default-cookies-list nil
       "A list holding the faces that preserve the default family and height when TOGGLE-SERIF is used.")
     (defvar ds/default-cookie nil
       "A list holding the faces that preserve the default family and height when TOGGLE-SERIF is used.")

     (setq ds/serif-preserve-default-list
           '(;; LaTeX markup
             font-latex-math-face
             font-latex-sedate-face
             font-latex-warning-face
             ;; org markup
             org-latex-and-related
             org-meta-line
             org-verbatim
             org-block-begin-line
             org-block
             org-code
             org-date
             ;; syntax highlighting using font-lock
             font-lock-builtin-face
             font-lock-comment-delimiter-face
             font-lock-comment-face
             font-lock-constant-face
             font-lock-doc-face
             font-lock-function-name-face
             font-lock-keyword-face
             font-lock-negation-char-face
             font-lock-preprocessor-face
             font-lock-regexp-grouping-backslash
             font-lock-regexp-grouping-construct
             font-lock-string-face
             font-lock-type-face
             font-lock-variable-name-face
             font-lock-warning-face))

     (require 'face-remap)

     (defun ds/toggle-serif ()
       "Change the default face of the current buffer to use a serif family."
       (interactive)
       (when (display-graphic-p)  ;; this is only for graphical emacs
         ;; the serif font familiy and height, save the default attributes
         (let ((serif-fam "Ubuntu")
               (serif-height 105)
               (default-fam (face-attribute 'default :family))
               (default-height (face-attribute 'default :height)))
           (if (not (bound-and-true-p ds/default-cookie))
               (progn (make-local-variable 'ds/default-cookie)
                      (make-local-variable 'ds/preserve-default-cookies-list)
                      (setq ds/preserve-default-cookies-list nil)
                      ;; remap default face to serif
                      (setq ds/default-cookie
                            (face-remap-add-relative
                             'default :family serif-fam :height serif-height))
                      ;; keep previously defined monospace fonts the same
                      (dolist (face ds/serif-preserve-default-list)
                        (add-to-list 'ds/preserve-default-cookies-list
                                     (face-remap-add-relative
                                      face :family default-fam :height default-height)))
                      (message "Turned on serif writing font."))
             ;; undo changes
             (progn (face-remap-remove-relative ds/default-cookie)
                    (dolist (cookie ds/preserve-default-cookies-list)
                      (face-remap-remove-relative cookie))
                    (setq ds/default-cookie nil)
                    (setq ds/preserve-default-cookies-list nil)
                    (message "Restored default fonts."))))))
   #+END_SRC

   A function to get an eslint executable for linting javascript. This
   should use the local instance installed in ~node_modules~ over any
   globally installed eslint package

   #+BEGIN_SRC emacs-lisp
     (defun ds/use-eslint-from-node-modules ()
       (let* ((root (locate-dominating-file
                     (or (buffer-file-name) default-directory)
                     "node_modules"))
              (eslint (and root
                           (expand-file-name "node_modules/eslint/bin/eslint.js"
                                             root))))
         (when (and eslint (file-executable-p eslint))
           (setq-local flycheck-javascript-eslint-executable eslint))))
   #+END_SRC

** Fence Edit

   Fork of [[https://github.com/aaronbieber/fence-edit.el][fence-edit]]

   #+BEGIN_SRC emacs-lisp
     (defcustom fence-edit-lang-modes
       '(("cl" . lisp-interaction-mode))
       "A mapping from markdown language symbols to the modes they should be edited in."
       :group 'fence-edit
       :type '(repeat
               (cons
                (string "Language name")
                (symbol "Major mode"))))

     (defcustom fence-edit-default-mode
       'text-mode
       "The default mode to use if a language-appropriate mode cannot be determined."
       :group 'fence-edit
       :type '(symbol))

     (defcustom fence-edit-blocks
       '(("^[[:blank:]]*\\(?:```\\|~~~\\)[ ]?\\([^[:space:]]+\\|{[^}]*}\\)?\\(?:[[:space:]]*?\\)$"
          "^[[:blank:]]*\\(?:```\\|~~~\\)\\s *?$"
          1)
         ("^<template>$" "^</template>$" web)
         ("^<script>$" "^</script>$" js)
         ("^<style[ ]?\\(scoped\\)?>" "^</style>$" css)
         ("^<style lang=\"stylus\"[ ]?\\(scoped\\)?>" "^</style>$" )
         ("^<style lang=\"scss\"[ ]?\\(scoped\\)?>" "^</style>$" scss)
         ("^<style lang=\"sass\"[ ]?\\(scoped\\)?>" "^</style>$" sass))
       "Alist of regexps matching editable blocks.

     Each element takes the form
     \(START-REGEXP END-REGEXP LANG-RULE)

     Where START- and END-REGEXP are patterns matching the start and end of
     the block, respectively.

     If LANG-RULE is a symbol, that symbol is assumed to be a language
     name.

     If LANG-RULE is an integer, it is assumed to be the number of a
     capture group to pass to `match-string' to get the language (a capture
     group within the START-REGEXP).

     If the language value with `-mode' appended to it does not resolve to
     a bound function, it will be used to look up a mode in
     `fence-edit-lang-modes'.  If the symbol doesn't match a key in
     that list, the `fence-edit-default-mode' will be used."
       :group 'fence-edit
       :type '(repeat
               (list
                (regexp "Start regexp")
                (regexp "End regexp")
                (choice (integer "Capture group number")
                        (symbol "Language name")))))

     (defconst fence-edit-window-layout 48529384
       "Register in which to save the window layout.

     Registers are chars, so this is set to an int that is not likely to be
     used by anything else.")

     (defvar-local fence-edit-previous-mode nil
       "Mode set before narrowing, restored upon widening.")

     (defvar-local fence-edit-overlay nil
       "An overlay used to indicate the original text being edited.")

     (defvar-local fence-edit-mark-beg nil
       "A marker at the beginning of the edited text block.

     Used to replace the text upon completion of editing.")

     (defvar-local fence-edit-mark-end nil
       "A marker at the end of the edited text block.

     Used to replace the text upon completion of editing.")

     (defvar-local fence-edit-block-indent nil
       "The indentation of the first line.

     Used to strip and replace the indentation upon beginning/completion of editing.")

     (defvar fence-edit-mode-map
       (let ((map (make-sparse-keymap)))
         (define-key map (kbd "C-c C-c") 'fence-edit-exit)
         (define-key map (kbd "C-c '")   'fence-edit-exit)
         (define-key map (kbd "C-c C-k") 'fence-edit-abort)
         (define-key map (kbd "C-x C-s") 'fence-edit-save)
         map)
       "The keymap used in ‘fence-edit-mode’.")

     (define-minor-mode fence-edit-mode
       "A minor mode used when editing a fence-edit block."
       nil "Fence-Edit"
       fence-edit-mode-map)

     (defvar fence-edit-mode-hook nil
       "Hook run when fence-edit has set the block's language mode.

     You may want to use this to disable language mode configurations that
     don't work well in the snippet view.")

     (defun fence-edit-mode-configure ()
       "Configure the fence-edit edit buffer."
       (add-hook 'kill-buffer-hook
                 #'(lambda () (delete-overlay fence-edit-overlay)) nil 'local))

     (add-hook 'fence-edit-mode-hook 'fence-edit-mode-configure)

     (defsubst fence-edit-set-local (var value)
       "Make VAR local in current buffer and set it to VALUE."
       (set (make-local-variable var) value))

     (defun fence-edit--make-edit-buffer-name (base-buffer-name lang)
       "Make an edit buffer name from BASE-BUFFER-NAME and LANG."
       (concat "*Narrowed Edit " base-buffer-name "[" lang "]*"))

     (defun fence-edit--next-line-beginning-position-at-pos (pos)
       "Return the position of the beginning of the line after the line at POS.

     Used to find the position at which the code to edit begins, covering
     for a common case where the block start regexp doesn't match the
     ending line break and that break gets sucked into the block of code to
     edit."
       (interactive)
       (save-excursion
         (goto-char pos)
         (forward-line)
         (line-beginning-position)))

     (defun fence-edit--get-block-around-point ()
       "Return metadata about block surrounding point.

     Return nil if no block is found."
       (save-excursion
         (beginning-of-line)
         (let ((pos (point))
               (blocks fence-edit-blocks)
               block re-start re-end lang-id start end lang)
           (catch 'exit
             (while (setq block (pop blocks))
               (save-excursion
                 (setq re-start (car block)
                       re-end (nth 1 block)
                       lang-id (nth 2 block))
                 (if (or (looking-at re-start)
                         (re-search-backward re-start nil t))
                     (progn
                       (setq start (fence-edit--next-line-beginning-position-at-pos (match-end 0))
                             lang (if (integerp lang-id)
                                      (match-string lang-id)
                                    (symbol-name lang-id)))
                       (if (and (and (goto-char (match-end 0))
                                     (re-search-forward re-end nil t))
                                (>= (match-beginning 0) pos))
                           (throw 'exit `(,start ,(match-beginning 0) ,lang)))))))))))

     (defun fence-edit--get-mode-for-lang (lang)
       "Try to get a mode function from language name LANG.

     The assumption is that language `LANG' has a mode `LANG-mode'."
       (let ((mode-name (intern (concat lang "-mode"))))
         (if (fboundp mode-name)
             mode-name
           (if (assoc lang fence-edit-lang-modes)
               (cdr (assoc lang fence-edit-lang-modes))
             fence-edit-default-mode))))

     (defun fence-edit-code-at-point ()
       "Look for a code block at point and, if found, edit it."
       (interactive)
       (let* ((block (fence-edit--get-block-around-point))
              (pos (point))
              (beg (make-marker))
              (end (copy-marker (make-marker) t))
              (block-indent "")
              edit-point lang code mode ovl edit-buffer vars first-line)
         (if block
             (progn
               (setq beg (move-marker beg (car block))
                     end (move-marker end (nth 1 block))
                     edit-point (1+ (- pos beg))
                     lang (nth 2 block)
                     code (buffer-substring-no-properties beg end)
                     mode (fence-edit--get-mode-for-lang lang)
                     ovl (make-overlay beg end)
                     edit-buffer (generate-new-buffer
                                  (fence-edit--make-edit-buffer-name (buffer-name) lang)))
               (window-configuration-to-register fence-edit-window-layout)
               (if (string-match-p (rx "\n" string-end) code)
                   (setq code (replace-regexp-in-string (rx "\n" string-end) "" code)))
               (setq first-line (car (split-string code "\n")))
               (string-match "^[[:blank:]]*" first-line)
               (setq block-indent (match-string 0 first-line))
               (setq code (replace-regexp-in-string (concat "^" block-indent) "" code))
               (overlay-put ovl 'edit-buffer edit-buffer)
               (overlay-put ovl 'face 'secondary-selection)
               (overlay-put ovl :read-only "Please don't.")
               (switch-to-buffer-other-window edit-buffer t)
               (insert code)
               (remove-text-properties (point-min) (point-max)
                                       '(display nil invisible nil intangible nil))
               (condition-case e
                   (funcall mode)
                 (error
                  (message "Language mode `%s' fails with: %S" mode (nth 1 e))))
               (fence-edit-mode)
               (fence-edit-set-local 'fence-edit-editor t)
               (fence-edit-set-local 'fence-edit-mark-beg beg)
               (fence-edit-set-local 'fence-edit-mark-end end)
               (fence-edit-set-local 'fence-edit-block-indent block-indent)
               (fence-edit-set-local 'fence-edit-overlay ovl)
               (fence-edit-set-local 'header-line-format "Press C-c ' (C-c apostrophe) to save, C-c C-k to abort.")
               (goto-char edit-point)
               (set-buffer-modified-p nil)))))

     (defun fence-edit--guard-edit-buffer ()
       "Throw an error if current buffer doesn't look like an edit buffer."
       (unless (bound-and-true-p fence-edit-editor)
         (error "This is not a fence-edit editor; something is wrong")))

     (defun fence-edit--abandon-edit-buffer (dest-buffer)
       "Trash the edit buffer and switch to DEST-BUFFER.

     The edit buffer is expected to be the current buffer."
       (interactive "P")
       (fence-edit--guard-edit-buffer)
       (let ((buffer (current-buffer)))
         (switch-to-buffer-other-window dest-buffer)
         (jump-to-register fence-edit-window-layout)
         (with-current-buffer buffer
           (set-buffer-modified-p nil))
         (kill-buffer buffer)))

     (defun fence-edit-save () 
       "Save the original buffer with the new text."
       (interactive)
       (fence-edit--guard-edit-buffer)
       (let ((beg fence-edit-mark-beg))
         (fence-edit-replace)
         (set-buffer-modified-p nil)
         (with-current-buffer (marker-buffer beg)
           (save-buffer))))

     (defun fence-edit-exit ()
       "Conclude editing, replacing the original text."
       (interactive)
       (fence-edit--guard-edit-buffer)
       (let ((code (buffer-string))
             (edit-point (point))
             (beg fence-edit-mark-beg)
             (end fence-edit-mark-end))
         (fence-edit-replace)
         (fence-edit--abandon-edit-buffer (marker-buffer beg))
         (goto-char (1- (+ beg edit-point)))
         (set-marker beg nil)
         (set-marker end nil)))

     (defun fence-edit-replace ()
       "Continue editing, replacing the original text."
       (interactive)
       (fence-edit--guard-edit-buffer)
       (let ((buffer (current-buffer))
             (code (buffer-string))
             (beg fence-edit-mark-beg)
             (end fence-edit-mark-end)
             (block-indent fence-edit-block-indent)
             (edit-point (point))
             (ovl fence-edit-overlay))
         (if (not (string-match-p (rx "\n" string-end) code))
             (setq code (concat code "\n")))
         (setq code (replace-regexp-in-string "\n" (concat "\n" block-indent) code))
         (setq code (concat block-indent code))
         (setq code (replace-regexp-in-string (concat "\n" block-indent "$") "\n" code))
         (with-current-buffer (marker-buffer beg)
           (goto-char beg)
           (undo-boundary)
           (delete-region beg end)
           (insert code))))

     (defun fence-edit-abort ()
       "Conclude editing, discarding the edited text."
       (interactive)
       (fence-edit--guard-edit-buffer)
       (let ((dest-buffer (marker-buffer fence-edit-mark-beg)))
         (fence-edit--abandon-edit-buffer dest-buffer)))


     (global-set-key (kbd "C-c '") 'fence-edit-code-at-point)
   #+END_SRC

** ChordPro Mode
   
   #+BEGIN_SRC emacs-lisp
     (defvar chordpro-font-lock-defaults
       '((("\\(\\[[^]]*\\]\\)" . font-lock-string-face)
          ("^\\(#.*\\)" . font-lock-comment-face)
          ("\\({subtitle[^}]*}\\)" . font-lock-type-face)
          ("\\({title[^}]*}\\)" . font-lock-keyword-face)
          ("\\({[^}]*}\\)" . font-lock-variable-name-face))))


     (define-derived-mode chordpro-mode text-mode "Chordpro"
       "Major mode for editing Chordpro files.
     Special commands:
     \\{chordpro-mode-map}"
       (setq font-lock-defaults chordpro-font-lock-defaults)
       (auto-fill-mode -1))

     (add-to-list 'auto-mode-alist '("\\.pro$" . chordpro-mode))
     (add-to-list 'auto-mode-alist '("\\.chopro$" . chordpro-mode))
     (add-to-list 'auto-mode-alist '("\\.chordpro$" . chordpro-mode))
   #+END_SRC


* Basic Packages

** Zenburn

   Set the alist first so that we can override some color they use in
   the theme, namely a darker background and added shades

   Then set up the configuration for the theme, mostly custom colors
   for various other packages and the header/footer lines

   #+BEGIN_SRC emacs-lisp
     (use-package zenburn-theme
       :ensure t
       :demand
       :init
       (defvar zenburn-colors-alist
         '(("zenburn-fg+1"     . "#FFFFEF")
           ("zenburn-fg"       . "#DCDCCC")
           ("zenburn-fg-1"     . "#656555")
           ("zenburn-bg-2"     . "#000000")
           ("zenburn-bg-1"     . "#0C0C0C")
           ("zenburn-bg-05"    . "#121212")
           ("zenburn-bg"       . "#1C1C1C")
           ("zenburn-bg+05"    . "#222222")
           ("zenburn-bg+1"     . "#2C2C2C")
           ("zenburn-bg+2"     . "#3C3C3C")
           ("zenburn-bg+3"     . "#4C4C4C")
           ("zenburn-red+1"    . "#DCA3A3")
           ("zenburn-red"      . "#CC9393")
           ("zenburn-red-1"    . "#BC8383")
           ("zenburn-red-2"    . "#AC7373")
           ("zenburn-red-3"    . "#9C6363")
           ("zenburn-red-4"    . "#8C5353")
           ("zenburn-orange"   . "#DFAF8F")
           ("zenburn-yellow"   . "#F0DFAF")
           ("zenburn-yellow-1" . "#E0CF9F")
           ("zenburn-yellow-2" . "#D0BF8F")
           ("zenburn-yellow-4" . "#B09F6F")
           ("zenburn-green-2"  . "#4F6F4F")
           ("zenburn-green-1"  . "#5F7F5F")
           ("zenburn-green"    . "#7F9F7F")
           ("zenburn-green+1"  . "#8FB28F")
           ("zenburn-green+2"  . "#9FC59F")
           ("zenburn-green+3"  . "#AFD8AF")
           ("zenburn-green+4"  . "#BFEBBF")
           ("zenburn-cyan"     . "#93E0E3")
           ("zenburn-blue+1"   . "#94BFF3")
           ("zenburn-blue"     . "#8CD0D3")
           ("zenburn-blue-1"   . "#7CB8BB")
           ("zenburn-blue-2"   . "#6CA0A3")
           ("zenburn-blue-3"   . "#5C888B")
           ("zenburn-blue-4"   . "#4C7073")
           ("zenburn-blue-5"   . "#366060")
           ("zenburn-magenta"  . "#DC8CC3"))
         "List of Zenburn colors.
     Each element has the form (NAME . HEX).

     `+N' suffixes indicate a color is lighter.
     `-N' suffixes indicate a color is darker.

     This overrides the colors provided by the `zenburn-theme' package.")


       :config
       (load-theme 'zenburn t)


       ;; default face customizations
       (zenburn-with-color-variables
         ;; darker region selection
         (set-face-attribute 'region nil :background zenburn-bg-2)
         ;; flat mode and header lines
         (set-face-attribute 'header-line nil :background zenburn-bg+1 :box nil)
         (set-face-attribute 'mode-line nil :background zenburn-bg+1 :box nil)
         (set-face-attribute 'mode-line-inactive nil :foreground zenburn-bg+3 :background zenburn-bg+05 :box nil)
         ;; italic comments
         (set-face-attribute 'font-lock-comment-face nil :slant 'italic)
         ;; set the verticle border color
         (set-face-attribute 'vertical-border nil :foreground zenburn-bg-1))

       ;; powerline colors
       (with-eval-after-load 'powerline
         (zenburn-with-color-variables
           (set-face-attribute 'powerline-active1 nil :background zenburn-bg+05 :foreground zenburn-green+1)
           (set-face-attribute 'powerline-active2 nil :background zenburn-bg+1 :foreground zenburn-green+1)
           (set-face-attribute 'powerline-inactive1 nil :background zenburn-bg+05 :foreground zenburn-bg+3)
           (set-face-attribute 'powerline-inactive2 nil :background zenburn-bg+05 :foreground zenburn-bg+3)))

       ;; flycheck use straight underline instead of wave
       (with-eval-after-load 'flycheck
         (zenburn-with-color-variables
           (set-face-attribute 'flycheck-error nil :underline `(:style line :color ,zenburn-red-1))
           (set-face-attribute 'flycheck-warning nil :underline `(:style line :color ,zenburn-yellow-2))
           (set-face-attribute 'flycheck-info nil :underline `(:style line :color ,zenburn-blue-2))))

       ;; company faces
       (with-eval-after-load 'company
         (zenburn-with-color-variables
           (set-face-attribute 'company-preview nil :background zenburn-green+2 :foreground zenburn-bg)
           (set-face-attribute 'company-preview-search nil :background zenburn-blue :foreground zenburn-bg)))

       (with-eval-after-load 'company-template
         (zenburn-with-color-variables
           (set-face-attribute 'company-template-field nil :background zenburn-yellow-1 :foreground zenburn-bg)))

       ;; faces for ledger mode
       (with-eval-after-load 'ledger-mode
         (zenburn-with-color-variables
           (set-face-attribute 'ledger-font-auto-xact-face nil :foreground zenburn-yellow)
           (set-face-attribute 'ledger-font-periodic-xact-face nil :foreground zenburn-green+3)
           (set-face-attribute 'ledger-font-xact-cleared-face nil :foreground zenburn-fg)
           (set-face-attribute 'ledger-font-xact-pending-face nil :foreground zenburn-yellow-2)
           ;; (set-face-attribute 'ledger-font-xact-open-face nil :foreground zenburn-bg-1)
           (set-face-attribute 'ledger-font-payee-uncleared-face nil :foreground zenburn-fg-1)
           (set-face-attribute 'ledger-font-payee-pending-face nil :foreground zenburn-yellow-2)
           (set-face-attribute 'ledger-font-pending-face nil :foreground zenburn-yellow-2)
           (set-face-attribute 'ledger-font-other-face nil :foreground zenburn-blue-1)
           (set-face-attribute 'ledger-font-posting-account-face nil :foreground zenburn-blue-3 )
           (set-face-attribute 'ledger-font-posting-amount-face nil :foreground zenburn-green+4 )
           (set-face-attribute 'ledger-font-posting-date-face nil :foreground zenburn-orange :underline t)
           (set-face-attribute 'ledger-font-report-clickable-face nil :foreground zenburn-fg+1)))

       ;; highlight-parentheses
       (with-eval-after-load 'highlight-parentheses
         (zenburn-with-color-variables
           (setq hl-paren-background-colors `(,zenburn-bg-2 ,zenburn-bg-1 ,zenburn-bg-05 ,zenburn-bg+05 ,zenburn-bg+1 ,zenburn-bg+2 ,zenburn-bg+3 ,zenburn-fg-1))
           (setq hl-paren-colors `(,zenburn-red-2 ,zenburn-green ,zenburn-orange ,zenburn-blue ,zenburn-yellow ,zenburn-cyan ,zenburn-magenta ,zenburn-fg+1))))



       ;; faces for avy
       (with-eval-after-load 'avy
         (zenburn-with-color-variables
           (set-face-attribute 'avy-background-face nil :foreground zenburn-fg-1 :background zenburn-bg-1)
           (set-face-attribute 'avy-lead-face-0 nil :foreground zenburn-fg+1 :background zenburn-blue-5)
           (set-face-attribute 'avy-lead-face-1 nil :foreground zenburn-fg+1 :background zenburn-bg-2)
           (set-face-attribute 'avy-lead-face-2 nil :foreground zenburn-fg+1 :background zenburn-blue-4)
           (set-face-attribute 'avy-lead-face nil :foreground zenburn-fg+1 :background zenburn-red-4))))

     (with-eval-after-load 'ivy
         (zenburn-with-color-variables
           (set-face-attribute 'ivy-current-match nil :foreground zenburn-fg+1 :background zenburn-bg+3 :box zenburn-blue :underline nil)
           (set-face-attribute 'ivy-subdir nil :foreground zenburn-blue-1 :background nil :weight 'bold)
           (set-face-attribute 'ivy-minibuffer-match-face-1 nil :background nil :box zenburn-green-1 :underline nil)
           (set-face-attribute 'ivy-minibuffer-match-face-2 nil :background nil :box zenburn-green-1 :underline nil)
           (set-face-attribute 'ivy-minibuffer-match-face-3 nil :background nil :box zenburn-red-1 :underline nil)
           (set-face-attribute 'ivy-minibuffer-match-face-4 nil :background nil :box zenburn-yellow-1 :underline nil)))
   #+END_SRC

** Try

   #+BEGIN_SRC emacs-lisp
     (use-package try
       :ensure t
       :pin melpa-stable)
   #+END_SRC

** Fontawesome

   #+BEGIN_SRC emacs-lisp
     (use-package fontawesome
       :ensure t
       :pin melpa
       :config
       (defun ds/vc-git-mode-line-string (orig-fn &rest args)
         "Replace Git in modeline with font-awesome git icon via ORIG-FN and ARGS."
         (let ((str (apply orig-fn args)))
           (concat [#xf126] ":" (substring-no-properties str 4))))

       (advice-add #'vc-git-mode-line-string :around #'ds/vc-git-mode-line-string))
   #+END_SRC

** Autorevert

   #+BEGIN_SRC emacs-lisp
     (use-package autorevert
       :diminish auto-revert-mode
       :config
       (global-auto-revert-mode))
   #+END_SRC

** Highlight Parentheses

   Enabled just for elisp right now, others if needed

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-parentheses
       :ensure t
       :diminish highlight-parentheses-mode
       :config
       (add-hook 'emacs-lisp-mode-hook
               '(lambda ()
                  (highlight-parentheses-mode))))
   #+END_SRC

** Subword

   #+BEGIN_SRC emacs-lisp
     (use-package subword
       :diminish subword-mode
       :config
       (global-subword-mode))
   #+END_SRC

** Winner

   #+BEGIN_SRC emacs-lisp
     (use-package winner
       :diminish winner-mode
       :config
       (winner-mode))
   #+END_SRC

** Adaptive Wrap
    
   #+BEGIN_SRC emacs-lisp
     (use-package adaptive-wrap
       :ensure t
       :pin gnu
       :init
       (defvar adaptive-wrap-extra-indent 2)
       :config
       (add-hook 'visual-line-mode-hook
                 '(lambda ()
                    (adaptive-wrap-prefix-mode (if visual-line-mode 1 -1)))))

   #+END_SRC
    
** Relative Line Numbers

   #+BEGIN_SRC emacs-lisp
     (use-package linum-relative
       :ensure t
       :pin melpa-stable
       :bind (("C-x l" . linum-relative-toggle))
       :diminish linum-relative-mode
       :demand
       :init
       (defvar linum-relative-current-symbol "")
       (defvar linum-relative-format "%3s "))

   #+END_SRC
** Dired

   #+BEGIN_SRC emacs-lisp
     (use-package dired
       :config
       (setq dired-listing-switches "-lha --group-directories-first"))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package dired-subtree
       :ensure t
       :commands (dired-subtree-toggle dired-subtree-cycle)
       :bind (:map dired-mode-map
                   ("i" . dired-subtree-insert))
       :config
       (setq dired-subtree-use-backgrounds nil))
   #+END_SRC

** Uniquify

   #+BEGIN_SRC emacs-lisp
     (use-package uniquify
       :config
       (customize-set-variable 'uniquify-buffer-name-style 'forward))
   #+END_SRC

** Magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :ensure t
       :pin melpa-stable
       :config
       (setq magit-merge-arguments '("--no-ff"))

       (defvar my-git-command-map
         (let ((map (make-sparse-keymap)))
           (define-key map "g" 'magit-status)
           (define-key map (kbd "C-g") 'magit-status)
           (define-key map "l" 'magit-log)
           (define-key map "f" 'magit-fetch-current)
           (define-key map "!" 'magit-blame-mode)
           (define-key map "c" 'magit-checkout)
           (define-key map (kbd "C-r") 'magit-rebase-step)
           (define-key map (kbd "C-f") 'magit-pull)
           (define-key map (kbd "C-p") 'magit-push)
           (define-key map (kbd "z z") 'magit-stash)
           (define-key map (kbd "z p") 'magit-stash-pop)
           (define-key map (kbd "C-t") 'git-timemachine)
           (define-key map (kbd "C-c") 'magit-create-branch)
           map)
         "Keymap of commands to load magit.")

       (define-key global-map (kbd "C-c g") my-git-command-map)
       (define-key global-map (kbd "C-c C-g") my-git-command-map)

       (setq global-magit-file-mode t)
       (add-hook 'magit-popup-mode-hook
                 (lambda()
                   (fit-window-to-buffer))))

   #+END_SRC

   Add ~git-timemachine~ for the ~C-c g C-t~ binding

   #+BEGIN_SRC emacs-lisp
     (use-package git-timemachine
       :ensure t
       :pin melpa-stable)
   #+END_SRC

** Window Purpose

   #+BEGIN_SRC emacs-lisp
     (use-package window-purpose
       :ensure t
       :pin melpa-stable
       :config
       (define-key purpose-mode-map (kbd "C-x b") nil)
       (define-key purpose-mode-map (kbd "C-x C-f") nil))
   #+END_SRC

** Org

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :ensure org-plus-contrib
       :mode (("\\.org$" . org-mode))
       :pin org
       :init
       (defvar org-directory "~/org" "Directory for org files.")
       (defvar org-agenda-directory "~/org/agenda" "Directory for org files.")
       (defvar org-mobile-directory "~/.org-mobile" "Directory for mobile org files.")
       (defvar org-time-clocksum-format "%d:%.02d")
       (setq org-journal-dir (concat org-directory "/journal/"))
       :config
       (condition-case nil
           (make-directory org-journal-dir t) ; make the org and journal dirs if they are not there already
         (error nil))
       (condition-case nil
           (make-directory org-mobile-directory t) ; make the org and journal dirs if they are not there already
         (error nil))

       (defun org-agenda-reload ()
         "Reset org agenda files by rescanning the org directory."
         (interactive)
         (setq org-agenda-files (directory-files-recursive org-agenda-directory "\\.org\\|[0-9]\\{8\\}"))
         (setq org-refile-targets '((org-agenda-files . (:level . 1)))))

       (org-agenda-reload)
       (setq org-agenda-file-regexp "\\([^.].*\\.org\\)\\|\\([0-9]+\\)")

       (setq org-log-done 'time)
       (setq org-enforce-todo-dependencies t)
       (setq org-agenda-dim-blocked-tasks t)
       (setq org-catch-invisible-edits t)

       (setq org-clock-idle-time 15)
       (setq org-clock-mode-line-total 'today)
       (setq org-log-into-drawer "LOGBOOK")
       (setq org-clock-into-drawer "LOGBOOK")
       (setq org-duration-format '(("h" . t) (special . 2)))



       ;; Resume clocking task when emacs is restarted
       (org-clock-persistence-insinuate)
       ;; Save the running clock and all clock history when exiting Emacs, load it on startup
       (setq org-clock-persist t)
       ;; Resume clocking task on clock-in if the clock is open
       (setq org-clock-in-resume t)
       ;; Do not prompt to resume an active clock, just resume it
       (setq org-clock-persist-query-resume nil)
       ;; Sometimes I change tasks I'm clocking quickly - this removes clocked tasks
       ;; with 0:00 duration
       (setq org-clock-out-remove-zero-time-clocks t)
       ;; Clock out when moving task to a done state
       (setq org-clock-out-when-done t)
       ;; Enable auto clock resolution for finding open clocks
       (setq org-clock-auto-clock-resolution (quote when-no-clock-is-running))
       ;; Include current clocking task in clock reports
       (setq org-clock-report-include-clocking-task t)
       ;; use pretty things for the clocktable
       (setq org-pretty-entities t)

       (setq org-todo-keywords
             '((sequence "TODO(t)" "IN-PROGRESS(i!)" "WAITING(w@)" "|" "WILL-NOT-IMPLEMENT(k@)" "DONE(d)")
               (sequence "BUG(b)" "RESOLVING(r!)" "|" "NON-ISSUE(n@)" "PATCHED(p)")))

       ;; defaut capture file
       (setq org-default-notes-file (concat org-directory "/todo.org"))

       (setq org-capture-templates
             '(("t" "Todo" entry (file+headline (concat org-directory "/todo.org") "Todo") "* TODO %?\n  SCHEDULED: %^{Schedule}t\n  %A")
               ("n" "Note" entry (file+headline (concat org-directory "/notes.org") "Notes") "* %? %U\n  %i")))

       (add-hook 'org-mode-hook
                 (lambda ()
                   (add-hook 'after-save-hook 'org-babel-tangle nil 'local-please)))

       (setq org-ditaa-jar-path "/usr/share/java/ditaa/ditaa-0_10.jar")
       (org-babel-do-load-languages
        'org-babel-load-languages
        '((sh . t)
          (ditaa . t)))

       ;; expand logbook on org all expand
       (defun ds/expand-logbook-drawer ()
         "Expand the closest logbook drawer."
         (interactive)
         (search-forward ":LOGBOOK:")
         (org-cycle))

       (defun ds/org-logbook-cycle-hook (ds/drawer-curr-state)
         "When the MY/VAR/CURR-STATE is \"all\", open up logbooks."
         (interactive)
         (message "State changed")
         (when (eq ds/drawer-curr-state "all")
           (ds/expand-logbook-drawer)))

       (add-hook 'org-cycle-hook 'ds/org-logbook-cycle-hook))


   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package org-bullets
       :ensure t
       :pin melpa-stable
       :config
       (add-hook 'org-mode-hook (lambda () (org-bullets-mode 1))))
   #+END_SRC

** Projectile

   #+BEGIN_SRC emacs-lisp
     (use-package projectile
       :ensure t
       :pin melpa-stable
       :init
       (defvar projectile-remember-window-configs t)
       :config
       (setq projectile-mode-line '(:eval
        (if (file-remote-p default-directory)
            " NoProj"
          (format " Proj[%s]"
                  (projectile-project-name)))))
       (projectile-global-mode))
   #+END_SRC

** Multiple Cursors

   #+BEGIN_SRC emacs-lisp
     (use-package multiple-cursors
       :ensure t
       :pin melpa-stable
       :bind (("C->" . mc/mark-next-like-this)
              ("C-<" . mc/mark-previous-like-this)))
   #+END_SRC

** Undo Tree

   More "sane" undo/redo system

   #+BEGIN_SRC emacs-lisp
     (use-package undo-tree
       :ensure t
       :pin gnu
       :diminish undo-tree-mode
       :config
       (global-undo-tree-mode))
   #+END_SRC

** Ace Window
   
   #+BEGIN_SRC emacs-lisp
     (use-package ace-window
       :ensure t
       :pin melpa-stable
       :bind (("C-x o" . ace-window)))
   #+END_SRC
   
** Exec Path from Shell

   #+BEGIN_SRC emacs-lisp
     (use-package exec-path-from-shell
       :ensure t
       :pin melpa-stable
       :config
       (exec-path-from-shell-initialize))
   #+END_SRC

** Flx
   #+BEGIN_SRC emacs-lisp
     (use-package flx
       :ensure t
       :pin melpa-stable)
   #+END_SRC
   
** Hydra
   #+BEGIN_SRC emacs-lisp
     (use-package hydra
       :ensure t
       :pin melpa-stable
       :config
       (defhydra hydra-zoom (global-map "C-c z")
         "zoom"
         ("g" text-scale-increase "in")
         ("l" text-scale-decrease "out"))
       (defhydra hydra-muti-cursor (global-map "C-c n" :hint nil)
       "
     ^Mark^
     ^^^^^^^^-----------------------------------------------------------------
     _n_: next    
     _p_: previous
     "
         ("n" mc/mark-next-like-this)
         ("p" mc/mark-previous-like-this)))
   #+END_SRC

** Avy

   #+BEGIN_SRC emacs-lisp
     (use-package avy
       :ensure t
       :pin melpa-stable
       :bind (("C-c j j" . avy-goto-line)
              ("C-c j w" . avy-goto-word-or-subword-1)
              ("C-c j c" . avy-goto-char)))
   #+END_SRC

** Smex

   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :ensure t
       :pin melpa-stable)
   #+END_SRC

** Ivy
   
   #+BEGIN_SRC emacs-lisp
     (use-package ivy
       :ensure t
       :demand
       :pin melpa-stable
       :diminish (ivy-mode . "")
       :bind (("C-x C-b" . ivy-switch-buffer)
              :map ivy-minibuffer-map
              ("C-'" . ivy-avy))
       :config
       (ivy-mode 1)
       ;; add ‘recentf-mode’ and bookmarks to ‘ivy-switch-buffer’.
       (setq ivy-use-virtual-buffers t)
       ;; recursive minibuffer
       (setq enable-recursive-minibuffers t)
       ;; count display
       (setq ivy-count-format "(%d/%d) ")
       ;; wrap
       (setq ivy-wrap t)
       ;; number of result lines to display
       (setq ivy-height 30)
       ;; no regexp by default
       (setq ivy-initial-inputs-alist nil)
       ;; configure regexp engine.
       (setq ivy-re-builders-alist
             ;; allow input not in order
             '((t . ivy--regex-fuzzy))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package ivy-hydra
       :ensure t
       :pin melpa-stable)
   #+END_SRC

** Counsel

   #+BEGIN_SRC emacs-lisp
     (use-package counsel
       :ensure t
       :pin melpa-stable
       :bind (("M-x" . counsel-M-x)
              ("C-x C-f" . counsel-find-file)
              :map read-expression-map
              ("C-r" . counsel-expression-history)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package counsel-projectile
       :ensure t
       :config
       (counsel-projectile-on))
   #+END_SRC

** Swiper

   #+BEGIN_SRC emacs-lisp
     (use-package swiper
       :ensure t
       :pin melpa-stable
       :bind (("C-s" . swiper)))
   #+END_SRC


* Programming Packages

** Flycheck

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck
       :ensure t
       :pin melpa-stable
       :init
       (setq-default flycheck-emacs-lisp-load-path 'inherit)
       :config
       ;; enable flycheck everywhere
       (add-hook 'after-init-hook #'global-flycheck-mode)
       (setq-default flycheck-disabled-checkers
                     (append flycheck-disabled-checkers
                             '(javascript-jshint)))
       (setq flycheck-display-errors-delay 0.4)
       (add-hook 'flycheck-mode-hook #'ds/use-eslint-from-node-modules)

       (defun ds/flycheck-auto-popup ()
         (let ((curbuf (current-buffer)))
           (if (/= (length flycheck-current-errors) 0)
               (progn
                 (flycheck-list-errors)
                 (switch-to-buffer-other-window flycheck-error-list-buffer))
             (let ((win (get-buffer-window flycheck-error-list-buffer)))
               (if win
                   (delete-window win))))
           (with-current-buffer curbuf
             (remove-hook 'flycheck-after-syntax-check-hook #'ds/flycheck-auto-popup t))))


       (defun ds/flycheck-save-hook ()
         (add-hook 'flycheck-after-syntax-check-hook #'ds/flycheck-auto-popup nil t))

       (add-hook 'flycheck-mode-hook
                 (lambda ()
                   (add-hook 'after-save-hook #'ds/flycheck-save-hook t t))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-popup-tip
       :ensure t
       :config
       (custom-set-variables
        '(flycheck-popup-tip-error-prefix "> "))
       (with-eval-after-load 'flycheck
         (flycheck-popup-tip-mode)))
   #+END_SRC

   The mode line coloring is disabled for now

   #+BEGIN_SRC emacs-lisp
     (use-package flycheck-color-mode-line
       :disabled
       :ensure t
       :pin melpa-stable
       :config
       (eval-after-load 'flycheck
         '(add-hook 'flycheck-mode-hook 'flycheck-color-mode-line-mode)))
   #+END_SRC

** Completion
   
   #+BEGIN_SRC emacs-lisp
     (use-package company
       :ensure t
       :diminish company-mode
       :config
       (add-hook 'after-init-hook 'global-company-mode)
       (setq company-dabbrev-downcase nil)
       (setq company-show-numbers t)
       (setq company-search-regexp-function #'company-search-flex-regexp)
       (setq company-tooltip-limit 20) ; bigger popup window
       (setq company-idle-delay .4)    ; decrease delay before autocompletion popup shows
       (setq company-echo-delay 0)    ; remove annoying blinking

       ;; add completion frontends for eshell
       (defun company-eshell-autosuggest-candidates (prefix)
         (let* ((history
                 (delete-dups
                  (mapcar (lambda (str)
                            (string-trim (substring-no-properties str)))
                          (ring-elements eshell-history-ring))))
                (most-similar (cl-find-if
                               (lambda (str)
                                 (string-prefix-p prefix str))
                               history)))
           (when most-similar
             `(,most-similar))))

       (defun company-eshell-autosuggest--prefix ()
         (let ((prefix
                (string-trim-left
                 (buffer-substring-no-properties
                  (save-excursion
                    (eshell-bol))
                  (save-excursion (end-of-line) (point))))))
           (if (not (string-empty-p prefix))
               prefix
             'stop)))

       (defun company-eshell-autosuggest (command &optional arg &rest ignored)
         (interactive (list 'interactive))
         (cl-case command
           (interactive (company-begin-backend 'company-eshell))
           (prefix (and (eq major-mode 'eshell-mode)
                        (company-eshell-autosuggest--prefix)))
           (candidates (company-eshell-autosuggest-candidates arg)))))
   #+END_SRC
   
** Commenter

   Originally for evil, but works great for vanilla

   #+BEGIN_SRC emacs-lisp
     (use-package evil-nerd-commenter
       :ensure t
       :pin melpa-stable
       :bind (("C-c C-/ C-/" . evilnc-comment-or-uncomment-lines)
              ("C-c C-/ C-l" . evilnc-comment-or-uncomment-to-the-line)
              ("C-c C-/ C-c" . evilnc-copy-and-comment-lines)
              ("C-c C-/ C-p" . evilnc-comment-or-uncomment-paragraphs)))
   #+END_SRC

** Golang

   #+BEGIN_SRC emacs-lisp
     (use-package go-mode
       :ensure t
       :pin melpa-stable
       :config
       (defun ds/go-hook ()
         "Hook for go-mode."
         ;; call gofmt for every save
         (add-hook 'before-save-hook 'gofmt-before-save)
         ;; customize the compile command
         (if (not (string-match "go" compile-command))
             (set (make-local-variable 'compile-command)
                  "go build -v && go test && go vet")))

       (add-hook 'go-mode-hook 'ds/go-hook))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package go-eldoc
       :ensure t
       :pin melpa-stable
       :config
       (add-hook 'go-mode-hook 'go-eldoc-setup)

       (set-face-attribute 'eldoc-highlight-function-argument nil
                           :foreground "blue"
                           :weight 'bold))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (use-package go-scratch
       :ensure t)
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package company-go
       :ensure t
       :config
       (setq company-go-insert-arguments nil)
       (setq company-go-show-annotation t)
       (add-hook 'go-mode-hook (lambda ()
                                 (set (make-local-variable 'company-backends) '(company-go))
                                 (company-mode))))
   #+END_SRC

** YAML

   #+BEGIN_SRC emacs-lisp
     (use-package yaml-mode
       :ensure t
       :pin melpa-stable
       :config
       (add-to-list 'auto-mode-alist '("\\.yaml\\'" . yaml-mode))
       (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-mode)))
   #+END_SRC

** Javascript

   Succumb to the 2 space indent cartel

   #+BEGIN_SRC emacs-lisp
     (use-package js
       :config
       (setq js-indent-level 2))
   #+END_SRC
   
   #+BEGIN_SRC emacs-lisp
     (use-package js2-mode
       :ensure t
       :pin melpa-stable
       :diminish js2-minor-mode
       :config
       (add-to-list 'auto-mode-alist '("\\.json$" . js-mode))
       (add-hook 'js-mode-hook 'js2-minor-mode)
       (add-hook 'js2-minor-mode-hook 'js2-mode-hide-warnings-and-errors)
       (setq-default js2-show-parse-errors nil)
       (setq-default js2-strict-missing-semi-warning nil))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package eslint-fix
       :ensure t
       :pin melpa-stable
       :config
       (add-hook 'js-mode-hook
                  (lambda ()
                    (add-hook 'after-save-hook 'eslint-fix nil t)))
       (add-hook 'vue-mode-hook
                  (lambda ()
                    (add-hook 'after-save-hook 'eslint-fix nil t))))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package vue-mode
       :ensure t
       :pin melpa-stable
       :config
       (add-to-list 'auto-mode-alist '("\\.vue\\'" . vue-mode)))
   #+END_SRC

   #+BEGIN_SRC emacs-lisp
     (use-package json-mode
       :ensure t
       :pin melpa-stable)
   #+END_SRC

** Web Mode (php+html+javascript)
   
   #+BEGIN_SRC emacs-lisp
     (use-package web-mode
       :ensure t
       :pin melpa-stable
       :config
       (setq web-mode-code-indent-offset 2)
       (add-to-list 'auto-mode-alist '("\\.html?\\'" . web-mode)))
   #+END_SRC

** Protobuf

   #+BEGIN_SRC emacs-lisp
     (use-package protobuf-mode
       :ensure t
       :config
       (add-hook 'protobuf-mode-hook
                 '(lambda ()
                    (when (not (boundp 'protobuf-protoc))
                      (flycheck-define-checker protobuf-protoc
                        "A protobuf syntax checker using the protoc compiler.

          See URL `https://developers.google.com/protocol-buffers/'."
                        :command ("protoc" "--error_format" "gcc"
                                  (eval (concat "--java_out=" (flycheck-temp-dir-system)))
                                  ;; Add the file directory of protobuf path to resolve import directives
                                  (eval (concat "--proto_path=" (file-name-directory (buffer-file-name))))
                                  "--proto_path=/usr/local/include"
                                  (eval (concat "--proto_path=" (getenv "GOPATH") "/src"))
                                  (eval (concat "--proto_path=" (getenv "GOPATH") "/src/github.com/grpc-ecosystem/grpc-gateway/third_party/googleapis"))
                                  source-inplace)
                        :error-patterns
                        ((info line-start (file-name) ":" line ":" column
                               ": note: " (message) line-end)
                         (error line-start (file-name) ":" line ":" column
                                ": " (message) line-end)
                         (error line-start
                                (message "In file included from") " " (file-name) ":" line ":"
                                column ":" line-end))
                        :modes protobuf-mode
                        :predicate buffer-file-name)))))
   #+END_SRC

   
* Applications

  Packages that are sort of "apps" on their own or interact with other
  system apps, outside of the "development" scope

** ZNC

   Connects to a ZNC server, used for persistant IRC presence and
   history playback.

   Config is done through the main config interface, saves it into
   ~custom.el~, which is not tracked.

   #+BEGIN_SRC emacs-lisp
     (use-package znc
       :ensure t
       :defer t)
   #+END_SRC

** Ledger

   The best accounting app out there

   #+BEGIN_SRC emacs-lisp
     (use-package ledger-mode
       :ensure t
       :config
       (add-to-list 'auto-mode-alist '("\\.ledger$" . ledger-mode))
       (add-to-list 'auto-mode-alist '("\\.ldg$" . ledger-mode))
       (add-to-list 'auto-mode-alist '("\\.rec$" . ledger-mode))

       (org-babel-do-load-languages
        'org-babel-load-languages
        '((ledger . t)))

       (defun find-ledger-directory ()
         "Get directory with ledger files."
         (let ((ledgerrc (concat (getenv "HOME") "/.ledgerrc")))
           (if (file-readable-p ledgerrc)
               (let ((conffile (with-temp-buffer
                                 (insert-file-contents ledgerrc)
                                 (split-string (buffer-string) "\n")))
                     (filename ""))
                 (dolist (ln conffile filename)
                   (message ln)
                   (if (string-match "^--file" ln)
                       (setq filename (replace-regexp-in-string "^--file \\([[:graph:]]\+\\)" "\\1" ln))
                     nil))
                 (string-trim (shell-command-to-string
                               (concat
                                "dirname "
                                filename)))))))

       (defun look-for-ledger-schedule-file ()
         "See if there is a file in the same directory as this ledger file with the same basename and a \".rec\" extenxtion. If so, set the `ledger-schedule-file variable' to this file for the local buffer."
         (if (not (string= (buffer-name) ledger-schedule-buffer-name))
             (set-local-variable
              'ledger-schedule-file
              (replace-regexp-in-string
               "\\.\\(ledger\\|ldg\\)" ".rec" (buffer-file-name) nil 'literal))))

       (add-hook 'ledger-mode-hook #'look-for-ledger-schedule-file)


       (defun org-to-tc ()
         "Convert the current org file into a timeclock file for ledger."
         (message "Saving timeclock file")
         (let ((cmdstr (concat "~/.emacs.d/bin/org2tc "
                               (buffer-file-name)
                               " > " (find-ledger-directory) "/"
                               (replace-regexp-in-string
                                (regexp-quote "\.org") ".timeclock" (buffer-name) nil 'literal))))
           (message cmdstr)
           (shell-command cmdstr)))


       (add-hook 'org-mode-hook
                 (lambda ()
                   (add-hook 'after-save-hook 'org-to-tc nil 'local-please)))

       (setq ledger-reports
             '(("asset/liabilities" "ledger -f %(ledger-file) bal assets liabilities")
               ("profit/loss" "ledger -f %(ledger-file) bal income expenses")
               ("checkbook" "ledger -f %(ledger-file) reg personal:assets:checking")
               ("cc" "ledger -f %(ledger-file) reg personal:liabilities and visa")
               ("loans" "ledger -f %(ledger-file) reg personal:liabilities and loan personal:expense and loan")
               ("bal" "ledger -f %(ledger-file) bal")
               ("reg" "ledger -f %(ledger-file) reg")
               ("payee" "ledger -f %(ledger-file) reg @%(payee)")
               ("account" "ledger -f %(ledger-file) reg %(account)"))))
   #+END_SRC

** Kubernetes

   #+BEGIN_SRC emacs-lisp
     (use-package kubernetes
       :ensure t
       :commands (kubernetes-overview)
       :config
       (setq kubernetes-poll-frequency 15))
   #+END_SRC

** Pacman

   #+BEGIN_SRC emacs-lisp
     (use-package arch-packer
       :ensure t
       :config
       (setq arch-packer-default-command "pacaur"))
   #+END_SRC


* Bootstrap

  ;; Local Variables:
  ;; eval: (when (not (fboundp 'ds/tangle-init)) (add-hook 'after-save-hook (lambda ()(org-babel-tangle)) nil t))
  ;; End:

